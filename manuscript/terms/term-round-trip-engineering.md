{lang=en}
### Round-trip Engineering

"Concept of being able to make any kind of change to a model as well as to the code generated from that model. The changes always propagate bidirectional and both artifacts are always consistent." (quoted from
  [Wikipedia](https://en.wikipedia.org/wiki/Model-driven_software_development))

D> ###### Comment (Gernot Starke)
D> In my personal opinion, it does not work in practical situations, only in hello-world-like scenarios, as the inverse abstraction (from low-level sourcecode to higher-level architectural elements) usually involves design-decisions and cannot realistically be automated.
D>
D> ###### Comment (Matthias Bohlen)
D>Recently I have seen code that originated from DDD where reverse engineering did indeed work.


{lang=de}
### Round-Trip-Engineering

„Konzept, gemäß dem an einem Modell sowie am aus diesem Modell
generierten Code alle Arten von Änderungen vorgenommen werden können.
Die Änderungen werden immer in beide Richtungen propagiert und beide
Artefakte sind immer konsistent." (Übersetztes englisches Zitat aus
[Wikipedia](https://en.wikipedia.org/wiki/Model-driven_software_development)[⁷⁹](#_bookmark181)).

[]{#_bookmark179
.anchor}⁷⁷<http://iso25000.com/index.php/en/iso-25000-standards/iso-25010>

[]{#_bookmark181
.anchor}⁷⁸<http://iso25000.com/index.php/en/iso-25000-standards/iso-25010>

⁷⁹<https://en.wikipedia.org/wiki/Model-driven_software_development>

![](media/image11.png){width="0.3937007874015748in"
height="0.3937007874015748in"}Anmerkung (Gernot Starke)

Meiner persönlichen Meinung nach funktioniert dies in der Praxis
nicht, sondern nur in „Hello-World"-ähnlichen Szenarien, da die
umgekehrte Abstraktion (von Quellcode niedriger Ebene zu
Architekturelementen höherer Ebene) in der Regel
Entwurfsentscheidungen erfordert und realistischerweise nicht
automatisiert werden kann.

Anmerkung (Matthias Bohlen)

Vor Kurzem habe ich aus DDD stammenden Code gesehen, bei dem Reverse
Engineering tatsächlich funktioniert hat.

